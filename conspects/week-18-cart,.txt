Что бы не выводились теги на странице в описание, нужно выводить их {!!$product->description!!}
=== Корзина ===
=== Работа с Корзиной ===
Дополянем наш роуте , там был  - Route::get('/product/{slug}' ,[StoreController::class ,'product']); , нам надо добавить привязку к модели, перед слагом прописать название Модели
Route::get('/product/{product:slug}' ,[StoreController::class ,'product']);
А дальше надо поменять запись в методе в конетроллере , раньше метод product принимал как параметр $slug брал ее из URL, теперь нам надо прописать product(Product $product) - имя Модели и  в переменной будет лежать уже конктреный обьект товара на который мы перешли , его слаг будет браться автоматически как из обьекта, так как мы его указали в роуте.
И теперь нам не надо делать

Создаем на стрнице товара форму которая будет отправлять количество покупак товара и сам товар, в скрытом инпуте отправляем какой id товара который ложим в корзину
Дальше у нас есть нексколько вариант как и куда отправлять данные из формы:

- session - если пользователь не залогинен то хоробы хранить в сессии у пользователя на компе:
Сессия это асс массив мы будет рабоать именно с ним
- DB - если пользователь вошел тогда записываем в базу связывая с его id

- cookie - не подходит так как они получаються в каждом запросе

Дальше стал вопрос как мы будет данные отравлять обычной формой или Ajax запросом что без перезагрузки страницы

=== Ajax ===
Форме задаем класс
{!! Form::open(['class' => 'form-add-to-cart']) !!}
Для проверить в главном шаблоне на налачие в хеде метатега
<meta name="csrf-token" content="{{ csrf_token() }}">
Проверяем подключение файла с js скриптами в низу шаблона

И дальше уже создаем в папке js новый файл cart.js  и require его в основной файл app.js и запускаем npm run watch
О боги, этот js я его тупо не знаю, разпишу тут все по шагово

Создали конст с этой формой
const formAddToCart  = document.querySelector('.form-add-to-cart')
Далие проверяем ее
if(formAddToCart){
    formAddToCart.addEventListener('submit', (e)=> {     - добавили обработчик события submit , стрелочная функция в нее передали е - событие так как это обьект
        e.preventDefault(); - тут уже отменили стандртное дейтсвие (тоесть когда мы нажимаем на кнопку buy страница перестала обновляться )
        const data = new FormData(formAddToCart); - тут создаем переменную data = новому обекту формДата к оторый мы передаем нашу форму и втроенная в js команада FormData собирает нам обьект из наших переданных в форме данных
        прим.
        product_id: 1
        qty : 2
        И дальше ее передает в axios и так как мы ее передаем постом То и в метода Контроллера нужно их получить в помощью класса Request $request и можеь вывести id покупаемного товара  return $request->product_id; и посмотреть все там же где и 123 (описанно ниже)
        axios.post('/cart/add',data); - тут мы прописываем что форму будем отправлять посмтом по такой то сылки
    })
}
Нам надо создать контроллер корзины
Дальше идем в роутс и нам надо прописать пути:
Route::post('/cart/add' ,[CartController::class ,'add']);
Внутри нового конетроллера создали новый метод add - для теста прописали там return 123
Дальше нажимаем на кнопку buy - заходим в консоль разработчика в вкладку network там выбираем отсортировать XHR и там будет нащ запрос add переходим в него и там есть вкладка preview и смотрим там будет отработан наш метод add а тоесть цыфры 123


=== Та же корзина на 18 недели ===
Окей тут такое дело , для работы с корзиной нам нужен функцииональный контроллер в котором будет прописанна логика работы корзины, у нас уже есть обычный конетроллер CartController в нем мы не будем писать фукции нам нужно создать свой Сервис Корзины CartService.php, создаем под это все отдельную папку в которой будут лежать такие вот Сервивы -> папка Services.
Дальше в этом файле прописываем namespace и создаем класс CartService
Дальше продумываем функионал самой корзины и создаем методы которые будут за них отвечать

Первый метод add добовлние товара и его количества в корзину , метод принимает add(Product $product, $qty) - сам товар и его колочество мы получаем из Контроллера который передает данные в метод

Так же создаем метод clear удаление всех товаров из корзины


Дальше метод remove удаление одного товара , передаем туда $id товара

И конечно же изменение количества товара в корзине changeQty - передавать сюда будем $id и $qty - новое количество товара

Еще один метод это totalSum() - для подсчета общей стоимости товаров


Тут стоит вопрос как мы этот класс CartService будем использовать в конетроллере?

=== Знакомство с Facades ===
Все это подченяеться понятию шаблон проектирования
https://refactoring.guru/ru

в php   есть такеи магические методы как __callStatic($method, $arg) -> он вызываеться тогда когда надо вызвать какой то Статический метод и указываем (название статического метода и аргуметы его )
в нутри метода уже создаеться новый образец  класса который мы хотим вызвать {
    $instance(переводиться как образец) = new CartService
    $instance->$method($arg) - и тут уже вызываеться этот метод с его аргументами

Но мы будем пользоваться фукциионалом который есть у Laravel:
Мы создаем Facade в папке app> создаем новую папку Facades и внутри создаем файл Cart.php
Как обычно прописываем namespace и создаем класс Cart extandes Facade(который Illuminate\Support\Facades\Facade; ){
    В это классе Facade есть уже реализованный метод
    protected static function getFacadeAccessor(){
        return 'Cart'; - этот метод должен возвращать нам название этого Фасада  И подключать в контроллер мы уже будет не CartService а этот фасад Cart И вызывать там уже как статический метод  прим. Cart::add()
    }
}
Дальше нам же этот фасад нужно как то связать с CartService.
Для этого идем в app>Providers>AppServiceProvider в методе boot() привязывем его:
$this->app->bind('Cart',CartService::class); - это говорит о том что когда мы будем обращаться к классу(фасаду) Cart на самом деле мы будем обращаться к CartService, это для того что б кажый раз не создовать обект класса как я рассписал выше в __callStatic()    Не забыть подключить сверху

Вроде как все вся подготовка выполнена , теперь и может идти в конетроллер и от туда передавать данные в методы сервиса данные через фасад
Cart:add(Product::findOrFail($request->product_id, $request->qty)); Тут мы обратились к методу сервиса CartService add(Product $product, $qty) и в его аргументы передеали id продукта которого запросили в базе данных по данным получиних из $request в который попдает данные формы отправленые из старницы где карточка товара при нажатие на кнопку купить.
В CartService в методе add проверили что туда доходят эти данные их можно вывести с помощью dd() и глянуть там же в панели разработчика.

Данные корзины мы будет хранить в сессии.
В сервисе в методе add прописываем Session - это такой же фасад так что его нужно так же сверху подключить
use Illuminate\Support\Facades\Session;
У Session есть разные методы один из них для записии в нее put() - сессия это массив ассоциативный , для запини нужно предоставить правильно данные. Для этого нужно понимать какие данные нам надо там хранить, а хранить надо те , которые мы будет выводить в корзине для пользователя
прим.
'cart' =>[  - все это данные которые будут храниться в сессии с именнем cart
   '1' => [   - Ключем массива надо сделать id товара для удобного удаление и поиска в массиве его значений
    'id' => 1,
    'price' => 100,
    'qty' => 1,
    'name' => Product,
    'img' => '',
],
   '2' => [
    'id' => 1,
    'price' => 100,
    'qty' => 1,
    'name' => Product,
    'img' => '',
],
 ]                         - товарах может быть много в корзине, каждый товар это массив и все товары вместе это тоже массив

Пишем это в метод add CartService
Записывать этот массив в сессию надо вот так:
$data = [
            'id' => $product->id,
            'name' => $product->name,
            'price' => $product->price,
            'img' => $product->img,
            'qty' => $qty,
];
Session::put('cart.' . $prodcut->id, $data) - Когда мы пишем 'cart(точка)1' - мы обращаемся к первому элементу массива. в нашем случаии мы подключили $id товара и передали переменную в которой массив данных которые передаем в корзину.

Вот мы понажимаем на кнопку в сессию продукты запишуться но мы не где не увидим это
Так что нам надо создать представление, из boostrap мы взяли модальное окно и вставили в нащ проект, там есть кнопка отдельно ее я встал в меню на иконку корзины просто взял от туда:
<a href="#" data-bs-toggle="modal" data-bs-target="#exampleModal">

и само окно вставили в самый низ стараницы после footera  и там есть в центральной части class="modal-body"
внутри него мы @include('_store.parts._cart')
Дальше идем и создаем этот cart :
В представлении что бы получить что то из сесси достаточно написать session()
Поэтому создаем цыкл
if(session('cart'))  - если пуста тогда корзина пуста , если что то есть то выводим что то
 Создаем таблцу для красивого отображение товаров
 и foreach(session('cart') as $product) - перебираем массив и получаем каждый продукт отдельно, так как получим мы опять массив по этому выводить надо так $product['img'] и так далие

else
  <p>Ваша корзина пуста</p>
endif

Что бы увидить товар надо его добавить обновить старницу и открыть корзину , надо это пофиксить.
Фиксить мы это идем в JS  тут будет инфа 1:53:28
В самом конетроллере мы возвращаем представление корзины, файл в котором мы сделали таблицу и отображаем содержимое:
return view('store.parts._cart');
А в JS при помощи axios мы отправляем запрос post и попадая в этот же метод add() получаем обратный ответ от сервера в котором содержиться данные , а уже в свойстве дата храниться наше  представление корзины в виде таблицы
В JS мы этот ответ получаем при помощи .then(function(response){})
Полностью это буде выглядит так:
        axios.post('/cart/add', data) - отправили постом туда данные из перенной data
            .then(function(responce){ - получили ответ в виде данных о представлении
                showCart(responce.data); - взяли через свойсво data таблицу из представлениия и передали в фукциию showCart в которой мы перезаписываем HTML разметку на новую с новыми товарами на пример
            });
    let cartModal = new bootstrap.Modal( document.getElementById('exampleModal') );  - это мы взяли из документации boostrap , для того что бы при покупке корзина открывалась сама
    function showCart(cart){
        document.querySelector('.modal-body').innerHTML = cart; -  мы перезаписываем HTML разметку на новую с новыми товарами, при нажатие на купить мы считываем новую таблицу с новым товарам и перезаписываем старый HTML и у нас получаеться акутальная корзина.
        cartModal.show(); - Тут мы в функцию добавили что после покупки открываеться корзина
    }


Дальше у нас проблема с тем что когда нажимаем на товар еще раз добавить он не суммируеться, фиксим:
У сессии метод get проверяем на наличии в сессии уже такго id если есть тогда
if( Session::get('cart.'.$product->id) ){
    Нам надо узнать сколько там едениц товара , создаем переменную $oldQty = Session::get('cart.'. $product->id.'.qty'); - выглядит это так cart.11.qty - это вложеность массива:
    'cart' => [
        11 =>[
            'qty' => 3  -  в переменную $oldQty записываем цыфру 3
        ]
    ]
    И дальше перезаписываем значение qty в сессии
    Session::put('cart.'.$product->id.'.qty', $oldQty + $qty);
}
else{
Иначе просто как раньше создаем новый
}

Дальше прописываем метод public static function totalSum(){ - cделать надо его статическим, так как мы будет пользоваться им внутри класса CartService.
    $total = 0; создали переменную
    foreach(Session::get('cart') as $product){ - Перебираем всю сессию карт
        total += $product['price'] * $product['qty']; - в переменную записываем прибавление каждой цены умноженой на колово товара
    }
    Session::put('totalSum',$total) - Для удобства вывода и что б не трогать сессию cart создаем новую сессию и записываем туда общую сумму.
    И теперь надо не забывать выводить эту функцию там где нам надо например в методе add в конце надо добавить  self::totalSum(); Ну и конечно же ввывести в представление {{session('totalSum')}}

}

== Очистка корзины ===
Создаем кнопку в модальном окне, и прописываем класс любой (clear-cart).
При клике на кнопку мы должны вешать событие

document.querySelector('.clear-cart').addEventListener('click',()=>{
    axios.post('/cart/clear') - посылаем запрос на вот такую страницу, нам жа теперь надо создать в роуте путь к ней и прописать класс и метод который за этот путь будут отвечать
    .then(function(responce){ - Опять будем получать ответ  и показывать вашу новую коризину с товарами ))... А точне без них . ЛОЛ мяууу.
        showCart(responce.data);
    });
});

Идем в роутс и создаем таковой:
Route::post('/cart/clear' ,[CartController::class ,'clear']);

В контроллере создаем такой метод И вызываем метод  clear у Фасада Cart  - это же CartService  И опять надо ж вернуть корзину для JS
Cart::clear();
return view('store.parts._cart');

Дальше в CartService нам надо удалить из сессии все данные о товарах и о сумме, вот таким способом:
Session::forget('cart');
Session::forget('totalSum');


== Удаление одного товара из корзины ==

Для начало нужно создать кпопку удаления в таблице в HTML  и для js нам надо будет знать id товара и как то его туда перадать, передават мы будем с помощью атрибута data-id="{{$product['id']}}"   и таким оброзом получиться что у каждой кнопки будет свой атрибут с data-id="38 (прим.)"  И для этой же кнопки указать класс для обращения в js remove-item.

Дальше идем в JS
Наша задача найти не динамического родителя и привязать событие click  к ниму так как каждый раз когда мы добовляем товар в коризину появляються новые кнопки удлаления товара, но они динамически  появиляються  на странице без перезагрузки странице и JS их просто не прочитает и событие не будет срабатывать на них так как он просто не знает о них сушествование до перезагрузки, только тогда он пробежиться по странице увидит их и сможет с ними взаимодействовать.
document.querySelector('.modal-body').addEventListener('click',()=>{}
Такой вот не динамический родитель это .modal-body оболочка куда мы подлючаем наше представление корзины, и теперь клик будет срабатывать по свей корзине куда бы мы не нажали, теперь надо это исправить:
document.querySelector('.modal-body').addEventListener('click',(e)=>{} - сюда в фукцию мы передали обьект event  - это значит что мы теперь может к нему обраться и назначить такой код  e.target.classList.contains('remove-item') - При клике на какой то элемент если у него есть класс remove-item тогда мы попали в точку дальше записываем код который должен выполниться

document.querySelector('.modal-body').addEventListener('click',(e)=>{
    if(e.target.classList.contains('remove-item')){   - Если есть такой класс то тогда выполни:
        const id = e.target.dataset.id; - создаем переменную id которая ровна id того елемента на который мы нажали dataset береь данные как раз из той data-id что мы указали в атрибуах кнопки
        axios.post('/cart/remove/'+ id) - как обычно придумываем адресс и передаем в него номер id из переменной , а в роутах создаем адресс с изменяющей {id}
            .then(function(responce){
                showCart(responce.data); - и так же отображаем новую корзину уже без этого товара
            });
    }
});

Дальше роутинг
Route::post('/cart/remove/{id}' ,[CartController::class ,'remove']);

Потом контроллер
    public function remove($id)   - создаем метод который получает id из роутинга
    {
        Cart::remove($id);  - вызываем метод из фасада который там надо создать
        return view('store.parts._cart'); - и для js возвращаем
    }

CartService:
    public function remove($id) - получили из контроллера
    {
        Session::forget('cart.'. $id);  - удалили из массива cart его елемент по id
        self::totalSum(); - обновили общую сумму товаров.
    }

== Меняем количество товаров в корзине ==

Создаем input type number  B value="{{$product['qty']}} - передаем актуальное количество    data-id="{{$product['id']}}  и опять для js передаем id товара датой"
и класс qty-item
Идем в JS
количество у нас получаеться тоже динамическое по этому опять обращаемся не к динамическому похоже будет на Удаленние
Но событие будет использовать change для input оно срабатывает сразу при выборе значения тоесть когда мы меняем цыфру то сразу будет сработка слушателя в js
Опять назвачаем обьект в фукции и ветвением проверяем на наличие в елементе класса qty item, если есть то возми из этого елемента значения атрибутов даты id продукта и value значение инпута тоесть количество товаров и отправь посмотом опять на придуманный адресс и передаем эти данные с помощью JSON

document.querySelector('.modal-body').addEventListener('change',(e)=>{
    if(e.target.classList.contains('qty-item')){
        const id = e.target.dataset.id;
        const qty = e.target.value;
        axios.post('/cart/change-qty',{
            id: id,
            qty: qty,
        })
            .then(function(responce){
                showCart(responce.data);
            });
    }
});

Роутинг
Route::post('/cart/change-qty' ,[CartController::class ,'change']);

Дальше в контроллер там создаем метод change
    public function change(Request $request) - сюда приходят данные из JS
    {
        if( $request->qty <= 0 ){  - обычноя проверка , если меньше или равна нулю тогда удаляыем продукт из карзины , иначе мы его меняем колочиесвто
            Cart::remove($request->id);
        }
        else{
        Cart::changeQty($request->id,$request->qty); - в сервисе создаем метод который принимает id и qty передаем туда их
        }
        return view('store.parts._cart'); - опять возващаем что б отобразить в JS новую таблицу
    }

В сервисе создаем метод changeQty($id, $qty)
    public function changeQty($id,$qty)
    {
        Session::put("cart.{$id}.qty", $qty); - перезаписываем в сессию количество так: выстраиваем обращение cart => [передаем сюда айди товара => [qty => передаем новое значение количества товара] ]
        self::totalSum(); - обновляем сумму товаров
    }

=== Страница оформления заказа ===
Добавиляем сылку на страницу на оформления заказа в модальном окне корзины
Создаем контроллер через composer  CheckoutController
Делаем роутинг на эту страницу гетом с контроллером и методом
в методе сразу возвращаем путь к файлу представления
Можно на эту страницу еще раз продублировать корзину
Создаем форму для обработки заказа  с данными пользователя с методом пост и роутинге создает роут с постом на новый метод checkoutSave(Request $request) будет принимать данные из формы 
.
