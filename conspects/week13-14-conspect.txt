composer cmd:
Комнадля для обновления композера
composer self-update
Когда мы заливаем прокет на github, папка vendor не заливаеться он в гитигноре, поетому перед тем как рабоать с скаченым проектом надо просписать команду :
composer install  - она проверить все зависимости в скачает все не достающие разширения

Заходим в папку с проетами:
cd domains/имя папки проекта  -

Создаем проект:
$ composer create-project laravel/laravel expName(имя папки которая создаться автоматически)

Переходим в папку с проекто для работы в ней
cd имя папки

Можно посмотреть все возможный команды:
php artisan  - команда помощник , покажет все возможные команды

Что бы не было в адрессной стоке название папки/public/... надо в опер сервере в настройках -> домены > выбрать Ручное + Автопоиск и указать имя домена выбрать папку public и нажать Добавить и потом сохрать и перезапустить сервер

- в папке app> Http идет работа с контролерами в Controllers
Перед созданиям роутинга в приложение нужно создать контролеры:
php artisan make:controller ИмяКонтролера   (он попадет в папку app>Http>Controllers)
Создаеться класс контроллер который сразу наследует значения Controllers.php
И в нем уже пишет методы (функции)

Дальше переходим в web.php в папке routes и подключаем новый контроллер свеху use App\Http\Controllers\MainController;
Подкючаем контроллер в виде массива и первым параметром идет название и обозночение что это класс через :: а вторым название метода который будет использовать

ВСЕ ЧТО ВОЗВАРАЩАЕТ КОНТРОЛЛЕР то мы видим на странице значит мы дождны передавать туда данные из папки resources/views/
    public function index()
    {
        return view('main.index') //? имя папки первое дальше могут быть еще папки или файлы но ставим . а не / меджу ними
        в функции view мы может передать вторым параметром ассациотивный массив получить его , написать или compact() из переменных,
        И потом вывести их уже на странице на как доступные переменные {{ $... }}
    }

Папка resources содержит:
- Папка css - все что мы будем писать в ней оно будет попадать в папку public и выводять пользователям, НО предварительно будет копилироваться webpack ом , это значит мы может использовать препроцесоры такие как SASS
- Папка js
- В папке lang содержаться технические команды об ошибках
- папку views в которой лежит welcome.blade.php представление сайта (верстака главной страницы фреймворка laravel)
    - Принято содздавать основные шаблобы для структуры страниц сайта и создавать папку layout  в ней уже создаем основной, главный шаблон сайта
    - команда @yield('name') - говорит о том что тут будет находиться какая то изменяемая информация (Простой пример поместить его в title в head ведь на каждой странице свой title описание страницы )
    - команада @extends('имя главного шаблона страницы') Что бы указать путь к представлению тоесть к нашему главному шаблону, мы начинаем шаги от папки Views как короня и уже внутри выбираем директории
    - команда @section('имя секции, которое мы будем вставлять в @yield, где угодно') отвечает за определение секции
    Короткая запись секции может быть в одну строку в таком видк @section('имя секции', $переменная) и без закрываеющего тега секции

- blade.php это шаблонизатор один из. Создан для упрощения написаня html вместе php   (так надо называть все файлы представления)
- blade имеет свой ситаксис написания
Если написать b: то увидем меню подсказок команд быстрого вывода
- {{ $exemple }} - безопасный вывод (так выглядит вывод переменой вместо <?=$exemple ?>)
- {!! $exemple !!} - не безопасный вывод, если надо вывести html теги например но можно так делать если вывод контролит админ , данные которые надо вывести но их вводит пользователь на сайте надо выводить {{  }}

Маршрутизация в папке Routes в файле web.php
- Каждая новая стрица на сайте это новый Routes::any('url этой страницы', [Контроллер к котому мы обращаемся::class, 'имя метода в котроллере'])
- Все данные которые мы отправляем на сайт в форме или еще как то она попадют в Класс Request, по этому он в контроллере по дефолту и висит use который подключает Request. Если мы обрабатываем форму POST то нужно не забыть указать это после класс Route::POST('и далиее')Посмотреть какие данные к нам приходят мы может через команду dd или dump($request->all())  - all() - это все данные которые содержит request, если нам нужны какие именно то мы должно указать какие. И тут же мы получаем ошибку 419 она значит что я не передал команду @csrf

csrf (Cross-site request forgery) - вид кибератаки,
Команда для зашиты пишеться такая @csrf и ставиться сразу после открытая формы  и она автоматические создает скрытый импут в форме который генеринует токен с уникальным шифром пользователя (secret)

===Валидация=====
Валидацию мы длеаем в контроллере в методе Устанавливаем в аргументах Request $request сюда прилетают данных с страницы и их с помощью метода ->validate() мы обратавыем
https://laravel.com/docs/8.x/validation#available-validation-rules
Все команды проверочные команды
Если валадиция проходит без ошибок мы получим данные из $request и может их обрабатывть
Пишем редирект redirect('/имя страницы') на этожу старницу или куда нам надо или же можно написать back() тогда он вернеться на ту сраницу с которой пришел
Так мы может написать функции после редиректа или бека ->with('ключ','значение') и оно запишеться в сессию пользователя и покажет ему ваше сообщение после отравки формы например, вызываем ее потом в представление как seccion('ключ')
Метод old('имя инпута') так же записываеться в сессию и при не удачной валидации не стрирает данные с полей которые прошли валидацию


=== Работа с Базами Данных ====
Соедение с БД. Указываем данные от mysql в файле .env и уже файл database.php из confing чтитывет данные из этого файла
За работу, создание отвечает папка database
Команда консоли php artisan migrate - выполняет миграцию (создание) всех методов up  в файл которые лежат в папке migrations
php artisan migrate:rollback - откат на 1 шаг назад
php artisan migrate:refresh  - Если мы что там подобовляли или изменили и нам это не надо, данная команда позволяем все очистить и мигрировать пустые файлы повторно
Что бы создать миграционый файл с всеми use и методами нужно выполнить команду:
php artisan make:migration create_categories_table  - очень важно правильно написать название файла первое слова значит действие которые мы хотим совершить например (create - создать таблицу) , второе слова это имя или название таблицы оно может быть двойным или болие тоже через _  и третие слово table говорит нам что это будет таблица
После того как создали файл, нужно его заполнить для создание таблицы в БД.
Для создания мы используем методы класса которые можно глянут:
https://laravel.com/docs/8.x/migrations#available-column-types
В одном из пунктов мы указали колонку с именем slug это ЧПУ(человеко понятный URL) пример. lara2/category/televizory (имя конкретной категории ) тоесть это слово televizory должно храниться в БД он должен быть ->unique
table->timestamps(); - эта колонка создает два значения 1. во сколько создали строку 2. когда обновляли строку

И вот наконец для работы с БД а имеено получаения от туда данных мы должны использовать Model
Лежит все это дело в папке app>models
Создаем модель файл:
php artisan make:model Category
А вот такая команда сразу создаст и модель и миграционный файл для нее
php artisan make:model Category -m

После того как создали в контроллеры нужно не забыть подключить класс модели
В controller мы получаем данных с помощи имени класса Модели: и метода all() выглядит так $categories = Category::all(); . И получили мы коллекцию обьектов, что бы вывсети их в представление нужно foreach получить каждый отедьный обьекто
и потом уже обратиться к конкретной колонке для получения строки
 @foreach ($categories as $category)
    <p>  {{ $category->name }}</p>
 @endforeach
Но тут же у модели есть и другие методы помимо all(). Мы сразу может получать не все а только те что нам надо с помощью where()(он срабатывает как И если where не один), еще есть orWhere() (или) - а получаем с запроса мы уже не коллекцию, а обьект класса Builder - а с билдра мы получить выводные данные не можем, нам надо закончить запрос, есть несколько вариант как это сделать:
- написать в конце строки ->get() Получаем колекцию обьектов
- first() - получаем первый продукт
- paginate(в скобочках указываем по сколько продуктов выводить) - получаем продукты сразу с пагинацией. Возвращаеться обьект LengthAwarePaginator и он уже содержит коллекцию обектов с товарами. Что бы вывести пагинацию в представление к массиву продуктов надо пременить метод ->links()

Что бы кастомизировать pagination, надо файл который отвечает за нее стили и который лежим в папке vendor, в которой менять не чего нету смысла, так как она не загужаеться на github  а значит при скачке ее надо будет установливать заново и все изменения сотруться мы должны нужные нам файлы копировать в рабочие места, что касаеться пагинацыии для этоного надо прописать команду:
php artisan vendor:publish --tag=laravel-pagination
Она переносит все папку pagination в папку resources>view  и там создает папку vendor и туда закинет blade файлы с предсталением. А в них уже мы меняет как нам угодно.

=== Акссесоры ===
Окей, новая тема: Обработка данных полученых и БД в МОДЕЛИ!!!
Открываем ту модель которой данных мы хотим как то обработать, и пишем  правильный МЕТОД у которого есть привила написания:
Имя метода должно обязательно состоять из слов get и Attribute а между ними ИМЯ колонки в базе данных выглядит так:
function public getNameAttribute($value){} а в агрументах функции дожно быть $value - сюда будут приходить данные из БД и это $value мы будет обрабатывть в самом методе , и возвращать его return. Оно все обработает перед тем как это попадет в представление и отдаст уже готовый вариант
Пример:
class Product extends Model
{
    use HasFactory;
    public function getImgAttribute($value)
    {
        return $value ? $value : '/img/product-img.jpg';
    }
}
Получили колонку img и тернарным проверили если она есть тогда выводим а если Null  тогда подтягываем картинку из локальной папки public

=== Подключение Bootstrap ===
Laravel Предоставляет пакет для работы с bootstrap
Устанавлиаем подолнение:
composer require laravel/ui
Мы говорим laravel что я буду использовать в своем прокете bootstrap так что подключи его
php artisan ui bootstrap
Мы подключили серьезное дополнение которое требует проверки зависимости и компилицию кода в файлах поэтому надо завново запустить :
npm install && npm run dev
Попросит еще раз зупустить :
npm run dev
=== Включаем авторизацию и регистрацию с  помощью бутстрап ===
php artisan ui bootstrap --auth
в node.js:
npm run install && npm run dev
После установок добавились новые папки  в views папка auth !!! ОЧЕНЬ ВАЖНО что установку делают в начале проекта

В корне проекта есть файл .env это наше окружение, где выполняються некие настрокие по типу базы данных
-Разботка идет в режиме разработчика и если есть ошибка в коде мы видим с помощю строки APP_DEBUG=true ошибку в браузере, если отключить ету строку то мы перейдем в режим пользователя и будет видит типичную ошибку по типу 500 или 404
Этот файл не попадает в git



Папка public это точка входа проекта , выполняеться некий роутинг и из index.php идет запуск проетка
- Все файлы отвечающие за отображение должны находиться в этой папке (стили, скриппты , картинки )










- папка Exceptions предназначена для каких то исклечений







php artisan  - команда помощник , покажет все возможные команды
php artisan db:seed - посев фейковой базы данных
php artisan make:factory CategoryFactory --model=Category
php artisan make:factory ProductFactory --model=Product
cls - очитка cmd

composer install - установка дополнений , при переносе проета, скаачки с github или создания проекта
composer require laravel/ui - установка пакета
php artisan ui bootstrap - подключения bootstrap

php artisan make:controller MainController  - создача контролера ( создаеться в папке app/http/controller/MainController)
php artisan migrate - запуск миграции , всех методов up в папке database migrations
php artisan migrate:rollback - откат на 1 шаг назад
php artisan migrate:refresh откат таблицы и создания ее заново
php artisan make:migration create_categories_table
php artisan make:model Product -m - создает модель и сразу миграцию для нее
php artisan vendor:publish --tag=laravel-pagination   - копируем файлы из папки vendor в нашу папкку view и там уже может редактировать эти файлы
не cmd:






node.js команды

npn install - установка пакетов
npm run dev - запуск режима разработчика , для удобства чтения
npm run prod - запуск режима минимизатора для хостинга
npm run watch -



