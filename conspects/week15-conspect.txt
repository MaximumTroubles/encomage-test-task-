Пары за 30.01.2021
PHP week 15 laravel framework
Пишем темы по порядку прохада на паре


=== Разбиваем на куски код ===
Например мы разбили картачку товара сверстую в отдельный файл _product.blade.php и создали папку parts в папке store. И все это дело может вставлять теперь туда где нужно вывести карточку товара.
Нижние подчеркывание в имени файла говорит о том что это будет куда то include


=== Связвыем таблицы из базы данных ===
Много к 1 (One To Many(Inverse)/BelongsTo) - Много продкутов ведут к одной категории
Задача получить Имя категории продукта. Работая с контроллером старицы где мы выводим продукт, мы ж там получаем данныне из модели Product а ней храниться только ID категории, поетому надо сделать запрос к таблице Categories и обьеденить эти две таблицы. Мы может написать SQL запрос но мы будем пользоваться функционалом Модели, есть различные условия связи между таблицами:
https://laravel.com/docs/8.x/eloquent-relationships#introduction
В нашей Модели Product мы хотим получить Имя категорий для этого нужно - написать метод название которого будет говорить о том что мы хотим получить. Есть правило наименования метода - Если одна категория свзяна то тогда в эдинствином числе называем, если Много связано , например у категори связанно много продуктов тогда в множестином числе. И должег называться так же как Модель с который мы будем связывать. 
Метод должен ВОЗВРАЩАТЬ условие связи между моделями:
return $this-> - (это наша Модель) , дальше идет  метод belongsTo(тут надо первым параметром прописать с какой модель мы связываемся  Category::class) - На этом этапе уже прошла связь и при выводе в представлние мы может обращаться к $product->category - category Это название метода и мы получим Обьект с которым уже может работать как надо $product->category->name - выводим и получаем название. Но каждый раз мы делаем запрос а это время на загрузку, а продуктов может быть тысячи будет очень много запросов. Что бы нам обьеденить запросы в контроллере где мы вызываем метод Product для вывода, нам надо установить связь  запроса  двух таблиц, для этого пишем: $products = Product::with('category')->get();  with - это метод обьединения а в скобках указываем название метода из Модели Product. а get() уже выполянет запрос. 

Остальные парамертры у метода belongsTo(): 2 параметр 'foreignKey' - это значит что если у таблицы к которой мы связаны название совпадает с колонкой category_id то _id метод добавит сам и не надо указывать этот параметр, но мы можем назвать колонку по другому , тогда и понадобить указать этот параметр и вписать туда название той колонки которую мы хотим связать. 3 параметр это название столбца текущей модели . 4 параметр название столбца связанной модели. 3 и 4 параметр если указывают на id то их укзывать не обязательно 

 ---- 1 к многим (One To Many) - это имеею виду что 1 Категория может вести к многим товарам:
 Теперь получаем Все продукты этой Категории. В Модели в котрой мы хотим установить свзяь с таблицей надо написать метод Имя у котрого уже будет в множественом числе , так как можем получить болие 1 товара. например products() - имя метода. Далие методы связи должны возвращать условие свзяи return $this->hasMany(Product::class); Тоесть модель Category имеет связи с Многими товарами метода Product 


=== Установка Laravel Debuger ===
https://github.com/barryvdh/laravel-debugbar
Команда для композера:
composer require barryvdh/laravel-debugbar --dev
И проверить что бы в файле .env было true в строке APP_DEBUG=true
НО!!! ===== Когда будем заливать на хостинг то нужно его отключить 

=== Роутинг, использования {slug} в связанных таблицах ===
В таблицах мы создаем колонку slug нужна она для определения сылки в доменной стороке на товар или категорию тоесть URL или ЧПУ. При формирование сылки в представление мы записываем в тег <a href="Тут нам надо либо сразу выводить колонку slug из таблицы или же страницу которая идет перед ней, роутиинг мы уже должны прописать web.php">
Далие переходим в web.php и тут указываем первым параметрои путь, мы можем написать так /category/{slug} - все что идет в фигурных скобках значит данные там меняються, а потом уже как обычно , класс контроллера и метод.
В контролле создаем метод который указали в роутинге. И этот {slug} автоматически попадает в метод (функицю) как ее параметр, их может быть много поэтому пишем через запятую в параметрах public function category($slug, $slug){
    В самом методе нам надо вытащить из таблицы колонку slug и проверить на равенство с теккущим $slug в URL . Выгялдит так
    $category = Category::where('slug', $slug)->firstOrFail(); - Если нам нажо их сравнить, тоесть постаивить '=' делать это не обязательно. firstOrFail() - https://laravel.com/docs/8.x/eloquent#retrieving-single-models  - это метод который найдет первое соответсвие и получиит его , но если не найдет остановит рабюоту и  сгенерирует и пакажет 404 ошибку 
}. 


=== Выводим Категории в Меню , Разшариваем переменную === 
Нам надо вывести категории на страницу по типу меню в хедере в классной работе они сделали сайдбар и для примера вывесли на всех страницах, я же хочу вывести на хедером навигационное меню по Категориям с главными категориями и под Категориями. Что ж мы знаем что можно в контроллере каждой старицы сайта можно запрашивать у модели названия Категорий и выводить их, но сколько ж надо продублировать кода для этого... 
Для того что бы этого не делать, Нам надо Разшарить переменную на ВСЕ представления 
https://laravel.com/docs/8.x/views#sharing-data-with-all-views
Окей, что бы разшарить надо зайти в папку app>providers>AppServiceProvider.php  и в методе boot(в буте прописываеться то что выполняеться до отображения представления) у класса View:: (нужен этот use Illuminate\Support\Facades\View;) вызоваем метод share() - этот метод принимает 2 параметра ключ => значение. Ключ - это название переменной которое мы сами придумываем(прим. shareCategories). Значение - это запрос к БД через Модель. 
Запрос строеться так:  Его описание в док. https://laravel.com/docs/8.x/eloquent-relationships#counting-related-models ,
https://laravel.com/docs/8.x/queries#grouping 
View::share('shareCategories', Category::withCount('products')->having('products_count','>', 0)->get());
Cдесь нам надо подсчитать количество продуктов каждой категории в связанной таблице ,Но не загружая их из базы данных. Помогает нам в этом метод withCount('имя таблицы для связи') и дальше на страницу представления мы дописываем как атрибут слово count. И получаем : $category->products_count что дает нам количество товаров каждой категории 

На главном layout странице мы подлюкчаем файл в котором содержиться код, который отвечает за отображения этого меню Категорий , дальше мы foreach перебираем переменную $shareCategories и достаем от туда те данные колонок таблицы которые нам надо.

=== Активный пункт меню Категорий === 
В Laravel существует класс Request у которого есть метод is() - этот метож возвращает true or false того Находимся мы на указанной странице:
Получаеться такой запрос: {{ Request::is('category/'.$category->slug) ? 'active' : '' }} - Тернарным методом указываем на каком слаге находимся тот и подсвечиваем. К Request мы так легко обращаемся так как он сразу прописанный в каждом контроллере 

=== Работа с blade section  ===
У нас в работе есть сенкция sidebar в main.blade, она написана так:
@section('sidebar')
@include('...')
@show - шоу в конце значит что мы хотим что б оно сразу отобразилось ,и потом на других страницах мы могли использовать эту секнция , как то ее дополняя. На другой странице мы так пишем @section('sidebar') а внутри пишем что то новое и если мы хотим что б там была там информация что в родительской секции тогда внутри пишем @parent до или после новго кода 

 

=== php artisan route:list - Получаем url адресса и контроллеры которые за них отвечают ===

=== Включаем авторизацию и регистрацию с  помощью бутстрап ===
php artisan ui bootstrap --auth
в node.js:
npm run install && npm run dev 
После установок добавились новые папки  в views папка auth !!! ОЧЕНЬ ВАЖНО что установку делают в начале проекта 
Устанавливаеться главный шаблон для работы в layouts, и нам не надо его писать с 0 
Установились все контроллеры на все новые шаги 
Добавились новые роуты в web.php

В laravel существует посредники middleware
Посредник,это класс который  срабатывает перед конроллером. говорит нам, если пользовательно не залогинин его перекидует на станицу /login
Route::get('/contacts', [MainController::class, 'contacts'])->middleware('auth') - тут мы добавили постреника auth, и если мы попытаеться зайти на страницу контакты то будет автоматически переброс на страцу входа /login.
Этот посредник работает на той странице к которой мы его препишем, с страниц  может быть мнного нет смысла дублировать, можно прописать в Контроллере тех страниц за которые контроллер отвечает: public function __construct(){ $this->middleware('auth) } - и так как этот метод последуют все остальные методы класса, он примениться к всем страницами переданные в return view 

Окей, идем дальше когда мы регистрируем пользователя, нас перекидует на страндартную страницу /home которая была содана когда мы подюключили bootstrap авторизацию, нам это не надо, что бы это изменить нам надо зайти app>providers>RouteServiceProvider :  и так практически сразу будет public conts HOME = '/вот тут на указать домащнию страницу, в нашем случаии /';



=== Админка  ====
Создаем отдельный контроллер в отдельной папки для Админки
php artisan make:controller Admin\AdminCotroller - так мы создаем и папку и сам контроллер.
И внутри уже работаем с методом как обычно, пока что мы только вывели представление на страницу из папки admin/ index.blade.php (которую скачали c шаблона админЛТЕ) - потом мы создали файл dashboard.blade.php разширили его основным шаблоном из index и в метод  вписываем return view('admin.dashboard');

Так сейчас работает в роутинге. Что такое админка ? это то место где будут (например. Категории) - создаваться, редактироваться, удаляться, сохраняться.(CRUD - create read update delete) И для всего этого надо будет создавать отделбные страницы по типу :
Route::get('/admin/category/create', [AdminController::class, 'index'])->middleware('admin')
Route::get('/admin/category/update', [AdminController::class, 'index'])->middleware('admin')
Route::get('/admin/category/save', [AdminController::class, 'index'])->middleware('admin')
Route::get('/admin/category/delete', [AdminController::class, 'index'])->middleware('admin')
И так же в конце нам прописать посредник который проверят на администратора.
И так же для Продуктов и всего остального на сайте. Получаеться много одинакового кода, есть способ как это сократить.
Окей, поехали у класса Route есть метод group(function()) - https://laravel.com/docs/8.x/routing#route-groups - который групирует, в нем надо указать безымянную функцию. Но перед методом group() ставиться метод middleware([внутри он принимает массив из посредников]), после него мы может указать Route prefix('admin') - в скобках указываем слово которое всегда посторяеться в URL. и дальше нам его указывать не надо, оно автоматически подствлеться в дальнейших путях. 

Вот такой код получилься:
Route::middleware(['auth'])->prefix('admin')->group(function(){
    //Ввнутри получаеться так:
    Route::get('/',[AdminController::class, 'index']);
});

Так как CRUD очень часто используемая вещь в laravel есть заготовка контроллера, создаеться командой через composer:
php artisan make:controller Admin\CategoryController --resource   - пристка --resource делает его ресурсным 
В контроллере есть уже готовын методы, и для того что б в роутинге не писать каждый отдельный метод на странице есть у класса Route спецальный метод resource() в который мы передаем название URL страницы и контроллер без массива , просто. Выглядит так:
Route::resource('/category', CategoryController::class);
Что бы посмотреть как это срабатывает пропишем команду:
php artisan route:list


Есть уже готовые админки для laravel:
Voyager:
https://voyager.devdojo.com/
https://www.youtube.com/watch?list=PL_UnIDIwT95NureFNedKN9_GA6UOiS2ox&v=cbFYqwzxGwY&feature=emb_rel_end&ab_channel=devdojo

Sleepingowl:
https://sleepingowladmin.ru/#/

Но мы же учиимся, поетому нам надо писать все с нуля, кроме верстки. Для этого мы возмем готовый шаблон

https://adminlte.io/
https://github.com/ColorlibHQ/AdminLTE
Тут мы скачали архив и перекинули в нащ проект (index.html, папка dist - в ней все стили, картинки, js файлы. И папку plugins)
И закадываем index.html в папку views > там создаем папку admin > и переиминовываем в index.blade.php
А папки dist and plagins закидываем сразу в public 
Создали папку layouts в папке admin и почистили все что не нам в файле index.blade.php. В центре файла где будет выводиться контет прописывает @yield('content')
И дальше уже создаем новые файлы и прописывавем там то что надо в сенкции content 
{{ Auth::user->name }} - Такое пишем там где надо вывести имя Админа 

