Maxym Rodziyevsky, [08.02.21 11:44]

=== Выводим отзывы на всех страницах ===
Для начала коненоч же нужно установить связь между таблицами, отзывы это Много к 1 (one to Many). В модели Product создаем метод с именем в множиственом числе, и внутри  устанавливаем связь методом hasMore():
return $this->hasMore(Review::class);
Связь устрановлена для это все нужно вывести на страницы. Первы способ это в контролле, сделать запрос в базу данных,в котром мы просим выведи нам продукты вмесье С категориями и вместе С количеством отзывов для этого товара:
$products = Product::with('categories')->withCount('reviews')->paginate(10); - Но таким способом мы получим это только на твой странице за которую отвечает этот контроллер, а мы хотим на всех страницах где есть карты товара, но не share переменую
==  Scopes Второй способ:  ==
https://laravel.com/docs/8.x/eloquent#query-scopes
Мы можем сразу в модель вшить такоей запрос. Окей, как нам это сделать
Для начла создаем в папке app папку Scopes  и внутри создаем файл с тематическим названием(прим. ProductScope.php)  и нам надо подключить 3 класса они указаны в документации
use Illuminate\Database\Eloquent\Builder;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Database\Eloquent\Scope;
После подключения создаем сам класс с названием таким же как названия файла и implements Scope
Внутри класса создаем метод apply(Builder $builder, Model $model) с такими параметрами где в $builder попадает основной запрос с конетроллера. Внутри метода исполнем такой код
$builder->(условия какие мы хотим выводить дополнительно) пример:
$builder->withCount('reviews');
Итого- мы все придумали сами, теперь нам надо сообщаить Модели что мы это будем использовать. Идем в модель Product
создаем метод protected static function booted(){
    static::addGlobalScope(new ProductScope) - не забыть подкючить класс сверху файла
}
Таким вот методом мы подключили глабальный скоп.
Теперь в предстовление будет заботать запрос к продукту ($product->reviews_count)
Если вдруг нам больше не понадобиться выводить то можно укзать метод ->withOutGlobalScope(ProductScope::class)->get();
Окей это все было глобальный скоп, но есть еще локальный
== Локальный скоп ==
Локальный скоп  формируеться в Модели, в самом классе скопа не чего писать не надо.
Определяеться он методом:
public function scope{имяПридумываемСами}($query) - передаем в параметр{
    например $query->where('recommended', 1) устаналиваем что выдай нам все строки в который колонка recommended = 1
}
Окей, определили и тепрь что б пременить это в представление Всего то нужно указать второе слово имени метода в конетроллере:
$products = Product::with('category')->recomended()->get();
Локальные скопы обычно делает на не большие веши, что из можно было вот таким каскадом формировать


=== CRUD в Админ панели ===
Что такое CRUD - create read update delete
На прошлом 15ом занатие мы успели создать конетроллер ресурсный
он нам сразу создал все нужные методы.
В роуте мы ему указали основу, путь к которому он будет формировать адрессные строки прим. /category/create или /category/edit и т.д.
Когда мы переключаемся по сылку , значит это было сделано методом GET у метода =index= как раз такой метод и указан, значит он должен отвечать за какой то вывод, а точнее вывод списка категорий.
В представление создает для него сылку как на него попасть
Как стало изветсно надо для указания сылки внутри тега лучше всего указывать {{asset(/admin/category)}} - asset прописывает полный путь к файлу
Для каждого CRUD елемента лучше создавать папку и туда складывать blade файлы.
Еще имя марштрута можно указывать через route('имя') - это имя мы должны указать в web.php добавить к строке ->name('имя'), для ресурсных путей имена создаються сами глянуть можно в route:list


В методе =create= указан метод GET значит мы туда переходим как по сылки и там в форме указываем что мы передаем по сылки(которая указана в маршрутизаторе в нашем случаии обратно на /admin/category) в метод Store данные, создания категории.

В методе =Store= указан метод передачи POST обратно на значит мы должны что то получить в из формы там в параметах написан $reqeust туда попадут данные из create.
Далие нам нужно проверить данные валидацией, если все впорядке тогда создать новую категорию new Category и расписать что куда попадает из $reqeust в БД и потом  сохранить.
прим: $category = new Category  $category->name = $reqeust->name и т.д

Работа к картинкой:

Первый способ::
Если мы просто укажем $reqeust->imgUpload (мы просто так назвали, можно по другому )  - то к нам прилетит только строка с названием а нам надо файл. Что б исправить надо указать метод $fname =  $request->file('imgUpload'); - воспримит как файл. Можно прописать
dd($fname) - и посмотреть какие нам данные доступны, Если файл не был выбран мы получаем null.
По этому пришем проверку:
if($fname != null){
    $path = $fname->store('uploads');    - окей, тут мы создали переменую $path в ней будет храниться путь к файлу который мы поместим в БД, метод store() - перемещает этот файл в папку  storage>app и там создает папку с именем которое мы укажим в скобках метода , ложит в нее изображение и создает уникальное имя
}
В папке public в корне проекта, появилась папка storage с символической (Symbolic link) сылкой, это грубо говоря сылка на папку основную папку куда сохраняються файлы storage
Вообще посмотреть и управлять загрузкой файлов можно в папке confing>filesystem.php  - По умолчанию стоит способ local, в этом файле можно написать свой диск с путями куда тебе нужно, но дело не для новичка.
https://laravel.com/docs/8.x/filesystem#file-uploads

Второй способ::
Получение пути к картинки через file manager:
В том html коде что мы скопировали на странице Unisharp File Manager Stand alone button
У input поменять name на img
$category->img = $reqeust->img
Но путь записываеться полный, и попадает в базу данных вместе с именем проекта, это не удобно потом его не поменять,для этого идем в папку confing>lfm.php  и так надо поменять у  disk => local  ,  мы в файле filesystem.php поменяли root у local на public_path('') и надо еще дописать 'url' => '', - что б путь правильный созвращалься и показывались прьевью картинок на странице
Дальше в этом файле есть 29строка allow_private_folder - это команда которая создает приватный папки для каждого пользователя который разгружает файлы. Один другого файлы не видит. Если поставить fasle тогда все картинку будут просто попадать в папку photos
allow_shared_folder - тут тоже на false поменять что было все видно кто может сюда загружать.
Картинка сразу поподает в папку public>photos  и тут же создаеться папка thumbs - это папка в которой дублируютьяс картинки но они обрезаные
rename_duplicates - можно поставить true  - переиминовывать дубликаты



$category->save() - все сохраняем
И прописываем редирект обратно на страницу со всеми категориями
return redirect('/admin/category');

== НОВЫЙ СПОСОБ СОХРАНЕНИЯ ==
В контроллре можно прописать Category::create($reqeust->all()); - это быстрое заполнение, идет создания в reqeust->all() - попадает только то что мы передали в форме постом, и так как все елементы формы нам подходят можно использовать такое быстрое заполнение, и все бы не чего но туда еще попадает _token который отвечет за безопасность и будет ошибка что такой колонки в БД нету.
Есть выход. в Модели можно прописать параметр protected $fillable = [] - в квадратные скобки мы записываем через запятую те колонки в которые должна попасть информация, и так как мы поставили тут ограничения, _token остаеться в неудел на него не пришло распоряжение, он проходит мимо и данные залитают в БД. гг


Метод == show($id) == нужен для отображения одной категории у него в $id попадает номер id категории и формирует сылку category/{id}
О больше нужен например для  заказов, например есть список заказов, мы нажимаем на один и переходим в этот show и смотрим подробноей, какой именно заказ был

Метод == edit($id) == открываеться GET переходим по сылке на него category/{$id}/edit  будет выводиться форма уже с данными для редактирования и  она дожна методом PUT вести наc на страницу /category/{$id} и при таких услових будет вызываться метод update

Метод == update(Request $reqeust, $id) ==  принимает данные из edit сохраняет их и переходит на страницу категорий или категории



Метод ==destroy($id)== удаляет по id из URL при помощи метода DELETE


=== Data Table плагин на JS  ===
Категории мы хотим выводить в виде таблицы для этого нужно сначла создать структуру таблицы написать а дальше займемся подключеним плагина, создаем на главной странице Категорий в админке. Форичем перебираем все категории и в ячейках таблицы можно указать в первой колонке можно указать {{ $loop->iteration }} - это переменная создаеться когда мы делаем перебор массива. А дальше по колонкам вставляем те данные которые хотим вывести из БД.
Окей, по получиться дефольтная таблица, а нам надо удобная и красивая, поэтому будем использовать DataTable.js
https://datatables.net/
Для установки у нас уже были файлы из админки что мы скачали, а так на сайте есть раздел download там можно все скаачать js и css.
Подключаем в главный файл Админки скрипт в конце  и так как мы будем часто вызывать создаем там же внизу @yield('js') -  и там страницах где будет вызывать скрипт внизу будем создавать секцию и в нее писать команду вызовать которая указана на сайте ,меняя только id елемента на наше имя которое мы добавим в тег <table id=""></table>.
А стили таблицы подключаем из главной страницы сайта  //cdn.datatables.net/1.10.23/css/jquery.dataTables.min.css  в хед все туда же на главном шаблоне.


=== HTML Laravelcollective ===
https://laravelcollective.com/docs/6.x/html  - сайт с документацией

composer require laravelcollective/html    - устанавливаем

Облегчаеться создание форм, в документации есть примеры,но не совсем простые
Пишеться форма в {!! Form:: !!} - потомучто там выводяться теги, по умолчанию в форме назначен POST метод и встроен CSRF защита тоже можно не указывать.
Форму можно просто открыть Form::open  а можно сразу открыть вместе с моделью а значит сразу подтянуться данные из БД, тоесть когда мы ходим отредактировать в админке продукт например мы открываем метод edit и формы которые там есть уже заполнены, Но интресный момент такая форма сразу записывает в быструю сесию данные и если мы например по валидации не смогли обновить продукт то сначала подтянуться на обнавленую страницу данные из сессии тоесть болие новые чем изначально из БД.
При создание и редакторивание формы одинаковы, поетому мы может вынести в отдебный файл как копмонет сами кусочки формы, разное будет это адресс куда отравляться будет и разными методами.
Первый параметр у input идет name,id вместе ,достаточно написать одно слово, второй парамет идет value , если не хотим задавать просто ставим null через запятую, если хотим укзать класс то ключ => значение напишем или другие любоый атрибуты.
Form:text('name', null или 'какое то value', ['class' => 'form-control'])
Именна инпутов лучше всего задавать тикие же как и имена колонок в БД
И тут мы дошли до  input textarea  и надо вставить == Визуальный редактор == (тема ниже)





=== Визуальный Редактор CKEditor 5   ===

https://ckeditor.com/ckeditor-5/


=== Unisharp Laravel File Manager и как дополнение для Визуального редактора ===

https://unisharp.github.io/laravel-filemanager/

Команды для установки в проект:

 composer require unisharp/laravel-filemanager  - скачивает файлы , устанавливает зависимость

 php artisan vendor:publish --tag=lfm_config  - Как только мы встречаем vendor:publish - это значит что из папки которую мы скачиваем  переместиться в нашу папки public. сам файлик confing будет отвечать за настройку что мы можем делать

 php artisan vendor:publish --tag=lfm_public  - копирует стили и скрипты для работы этого file manager

 php artisan storage:link  - делаем символьную сылку, куда будут картинки попадать

 Далие в .env надо отредактировать строку APP_URL указать так правильное название проекта APP_URL=http://lara2   - дополнению важен этот путь он его будет где то использовать

Там нужно еще скопировать группу путей  в web.php
 Route::group(['prefix' => 'laravel-filemanager', 'middleware' => ['web', 'auth']], function () {
     \UniSharp\LaravelFilemanager\Lfm::routes();
 });

 Все Установка все!

Дальше нужно его интегрировать и выбрать в какой Визуальный редактор, мы выбрали CKEditor 5.
Но сначала нужно подключить сам CKEditor 5.
Заходим в интеграцию выьераем ВР и копируем cdn скрипта  в файл где будет форма с редактором.
 <script src="//cdn.ckeditor.com/4.6.2/standard/ckeditor.js"></script>

 CKEDITOR.replace('description'); - и такую команду запустить и у нас заработает сам CKEditor но без filemanager еще. (в скобках указываем имя textarea)
 Все textarea уже готова , редактор есть. Там есть иконка картинки, когда мы ее нажимаем получаем форму в которую нужно записать СЫЛКУ на картинку которая уже должна лежать в папки проекта public что весьма не удобно, для этого нам и нужен этот filemanager
 Что бы в эту форму добавить опции выбора изображение из managera нужно прописать следущие:

var options = {
    filebrowserImageBrowseUrl: '/laravel-filemanager?type=Images',
    filebrowserImageUploadUrl: '/laravel-filemanager/upload?type=Images&_token=',
    filebrowserBrowseUrl: '/laravel-filemanager?type=Files',
    filebrowserUploadUrl: '/laravel-filemanager/upload?type=Files&_token='
}; - вставляем перед CKEditor.replace и добовляем вторым параметром туда эту переменную  - Эти переменную это пути которые у нас уже есть в проекте после того как мы прописали команду для установки filemanager.
 CKEDITOR.replace('description', options);

== Stand alone button ==
https://unisharp.github.io/laravel-filemanager/integration - внизу все написанно как ее интегрировать.  Это отдельная кпока для загрузки изображений все ВР.






laravel Collective:
composer require laravelcollective/html
Файл менеджер: Unisharp
composer require unisharp/laravel-filemanager
php artisan vendor:publish --tag=lfm_config
php artisan vendor:publish --tag=lfm_public
php artisan storage:link


ffffff
